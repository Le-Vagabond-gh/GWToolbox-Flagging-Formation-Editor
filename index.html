<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GWToolbox Flagging Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }
        
        .left-container {
            display: flex;
        }
        
        .right-container {
            width: 200px;
            background: #252525;
            border-left: 1px solid #404040;
            display: flex;
            flex-direction: column;
        }

        .code-panel {
            background: #252525;
            border-right: 1px solid #404040;
            display: flex;
            flex-direction: column;
            width: 300px;
        }
        
        .hotkey-offset-control {
            padding: 8px 16px;
            background: #2a2a2a;
            border-bottom: 1px solid #404040;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .hotkey-offset-control label {
            color: #aaa;
            white-space: nowrap;
        }
        
        .hotkey-offset-control input {
            width: 50px;
            background: #1e1e1e;
            border: 1px solid #404040;
            border-radius: 3px;
            color: #d4d4d4;
            padding: 4px 6px;
            font-size: 12px;
            text-align: center;
        }
        
        .hotkey-offset-control input:focus {
            outline: none;
            border-color: #007acc;
        }
        
        .history-panel {
            width: 150px;
            background: #252525;
            border-right: 1px solid #404040;
            display: flex;
            flex-direction: column;
        }
        
        .formations-section {
            border-bottom: 1px solid #404040;
            margin-bottom: 10px;
        }
        
        .formations-title {
            padding: 8px 16px;
            font-weight: 600;
            font-size: 13px;
            color: #aaa;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .formation-item {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .formation-item:hover {
            background-color: #333;
        }
        
        .formation-item.user-saved {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .formation-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .formation-name[contenteditable="true"] {
            background: #1e1e1e;
            border: 1px solid #555;
            padding: 2px 5px;
            outline: none;
        }
        
        .delete-formation {
            color: #ff6b6b;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.7;
        }
        
        .delete-formation:hover {
            opacity: 1;
        }
        
        .save-button {
            background: #2c5282;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .save-button:hover {
            background: #3182ce;
        }

        .panel-header {
            padding: 12px 16px;
            background: #2d2d2d;
            border-bottom: 1px solid #404040;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 40px;
        }

        .panel-content {
            flex: 1;
            padding: 16px;
            max-height: 100%;
        }
        
        #historyList {
            overflow-y: auto;
            max-height: calc(100vh - 45px);
        }
        
        .history-item {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .history-item:hover {
            background-color: #333;
        }
        
        .history-item.active {
            background-color: #2c5282;
        }
        
        .history-timestamp {
            color: #aaa;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .history-preview {
            color: #ddd;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        textarea {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            resize: none;
            outline: none;
            overflow-y: visible;
        }

        textarea:focus {
            border-color: #007acc;
        }

        .visual-panel {
            flex: 1;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .icon-button {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(45, 45, 45, 0.7);
            border: 1px solid #404040;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .help-button {
            bottom: 20px;
            right: 20px;
        }
        
        .settings-button {
            top: 20px;
            right: 20px;
        }
        
        .icon-button:hover {
            background: rgba(45, 45, 45, 0.9);
            color: white;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background: #252525;
            border: 1px solid #404040;
            border-radius: 6px;
            width: 600px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            color: #aaa;
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: white;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: white;
        }
        
        .modal-section {
            margin-bottom: 20px;
        }
        
        .modal-section h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #ddd;
        }
        
        .modal-section p {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        .modal-section a {
            color: #4a9eff;
            text-decoration: none;
        }
        
        .modal-section a:hover {
            text-decoration: underline;
        }

        .canvas-container {
            position: relative;
            width: min(900px, calc(100vh - 40px));
            height: min(900px, calc(100vh - 40px));
            max-width: 100%;
            max-height: 100%;
        }

        canvas {
            border: 1px solid #404040;
            background: #0d0d0d;
            border-radius: 8px;
            width: 100%;
            height: 100%;
            display: block;
        }

        .hero-dot {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            cursor: move;
            user-select: none;
            transform: translate(-50%, -50%);
            transition: box-shadow 0.2s;
        }

        .hero-dot:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .hero-dot.player {
            background: #4a9eff;
            color: white;
            z-index: 10;
        }

        .hero-dot.member {
            color: white;
        }
        
        .hero-dot.selected {
            box-shadow: 0 0 0 3px #fff, 0 0 10px 5px rgba(255, 255, 255, 0.5);
        }
        
        .hero-dot.member-1 { background: #ff6b6b; }
        .hero-dot.member-2 { background: #4ecdc4; }
        .hero-dot.member-3 { background: #ffbe0b; }
        .hero-dot.member-4 { background: #8338ec; }
        .hero-dot.member-5 { background: #fb5607; }
        .hero-dot.member-6 { background: #3a86ff; }
        .hero-dot.member-7 { background: #06d6a0; }

        .info-panel {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(45, 45, 45, 0.9);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 12px;
            border: 1px solid #404040;
            transition: opacity 0.3s, transform 0.3s;
            opacity: 1;
            transform: translateY(0);
        }
        
        .info-panel.hidden {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }

        .info-panel div {
            margin: 4px 0;
        }

        .info-panel label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            margin: 6px 0;
        }

        .info-panel input[type="checkbox"] {
            cursor: pointer;
        }
        
        .zoom-control {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(45, 45, 45, 0.9);
            padding: 10px 14px;
            border-radius: 6px;
            border: 1px solid #404040;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            user-select: none;
        }
        
        .zoom-button {
            width: 24px;
            height: 24px;
            background: #2c5282;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .zoom-button:hover {
            background: #3182ce;
        }
        
        .zoom-button:active {
            background: #2c5282;
        }
        
        .zoom-level {
            min-width: 45px;
            text-align: center;
            font-weight: 600;
            color: #ddd;
        }
        
        .zoom-reset {
            padding: 4px 8px;
            background: #404040;
            border: none;
            border-radius: 3px;
            color: #ddd;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .zoom-reset:hover {
            background: #505050;
        }
        
        .canvas-container.panning {
            cursor: grabbing !important;
        }
        
        .github-link {
            margin-top: auto;
            border-top: 1px solid #404040;
        }
        
        .github-link a {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 16px;
            color: #aaa;
            text-decoration: none;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .github-link a:hover {
            color: #fff;
            background-color: #2a2a2a;
        }
        
        .github-link svg {
            fill: currentColor;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-container">
            <div class="code-panel">
                <div class="panel-header">
                    <span>Configuration</span>
                    <button id="saveFormationBtn" class="save-button">üíæ Save</button>
                </div>
                <div class="hotkey-offset-control">
                    <label for="hotkeyOffset">Start hotkeys at:</label>
                    <input type="number" id="hotkeyOffset" min="0" max="999" value="0" />
                </div>
                <div class="panel-content">
                <textarea id="codeEditor" spellcheck="false"></textarea>
                </div>
            </div>
            <div class="history-panel">
                <div class="panel-header">History</div>
                <div class="panel-content" id="historyList">
                    <!-- History items will be added here -->
                </div>
            </div>
        </div>
        <div class="visual-panel">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div id="heroContainer"></div>
                <div class="icon-button help-button" id="helpButton">?</div>
                <div class="icon-button settings-button" id="settingsButton">‚öôÔ∏è</div>
                <div class="zoom-control">
                    <button class="zoom-button" id="zoomOut" title="Zoom Out">‚àí</button>
                    <div class="zoom-level" id="zoomLevel">100%</div>
                    <button class="zoom-button" id="zoomIn" title="Zoom In">+</button>
                    <button class="zoom-reset" id="zoomReset" title="Reset Zoom & Pan">Reset</button>
                </div>
                <div class="info-panel" id="controlsPanel">
                    <div><strong>Controls:</strong></div>
                    <div>‚Ä¢ Drag dots to reposition</div>
                    <div>‚Ä¢ Shift+click to select multiple</div>
                    <div>‚Ä¢ Arrow keys to nudge by 1 unit</div>
                    <div>‚Ä¢ Hold Shift while dragging to constrain</div>
                    <div>‚Ä¢ Hold Ctrl to rotate around player</div>
                    <div>‚Ä¢ Mouse wheel to zoom</div>
                    <div>‚Ä¢ Middle-click drag to pan</div>
                    <div>‚Ä¢ Edit code to update visual</div>
                    <label>
                        <input type="checkbox" id="showInTheAreaRange">
                        <span id="inTheAreaRangeLabel"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="showNearbyRange">
                        <span id="nearbyRangeLabel"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="showAdjacentRange">
                        <span id="adjacentRangeLabel"></span>
                    </label>
                    <label>
                        <input type="checkbox" id="highlightIntersections">
                        <span>Highlight intersections</span>
                    </label>
                </div>
            </div>
        </div>
        <div class="right-container">
            <div class="formations-section">
                <div class="formations-title">Pre-bundled Formations</div>
                <div id="prebundledFormations">
                    <!-- Pre-bundled formations will be added here -->
                </div>
            </div>
            <div class="formations-section">
                <div class="formations-title">üíæ Saved Formations</div>
                <div id="savedFormations">
                    <!-- User saved formations will be added here -->
                </div>
            </div>
            <div class="github-link">
                <a href="https://github.com/Le-Vagabond-gh/GWToolbox-Flagging-Formation-Editor" target="_blank" rel="noopener noreferrer">
                    <svg height="24" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="24" data-view-component="true">
                        <path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path>
                    </svg>
                    <span>GitHub</span>
                </a>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content">
            <div class="modal-close" id="closeModal">&times;</div>
            
            <div class="modal-section">
                <h3>About GWToolbox++</h3>
                <p>This tool is designed to work with GWToolbox++, a powerful enhancement for Guild Wars.</p>
                <p>For more information and to download GWToolbox++, visit: <a href="https://www.gwtoolbox.com/" target="_blank">https://www.gwtoolbox.com/</a></p>
            </div>
            
            <div class="modal-section">
                <h3>Hero Formations Guide</h3>
                <p>For detailed information on hero formations and flagging techniques, check out:</p>
                <p><a href="https://gwpvx.fandom.com/wiki/User:Yung_Rocks/Sandbox/Formations" target="_blank">https://gwpvx.fandom.com/wiki/User:Yung_Rocks/Sandbox/Formations</a></p>
            </div>
            
            <div class="modal-section">
                <h3>Using Your Formations</h3>
                <p>To use these formations in Guild Wars:</p>
                <p>1. Copy the formation code from this editor</p>
                <p>2. Paste it into your GWToolbox.ini file located at:</p>
                <p><code>%USERPROFILE%\Documents\GWToolbox\%COMPUTERNAME%\GWToolbox.ini</code></p>
                <p>3. Restart Guild Wars or reload your settings in GWToolbox++</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const codeEditor = document.getElementById('codeEditor');
        const heroContainer = document.getElementById('heroContainer');

        let CENTER_X = 450;
        let CENTER_Y = 450;
        let SCALE = 0.35; // Scale to fit 1200 units at edge
        let canvasSize = 900;
        let zoomLevel = 1.0;
        let panOffsetX = 0;
        let panOffsetY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        
        // Function to update canvas dimensions based on container size
        function updateCanvasDimensions() {
            const container = document.querySelector('.canvas-container');
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width, rect.height);
            
            canvasSize = size;
            canvas.width = size;
            canvas.height = size;
            CENTER_X = size / 2 + panOffsetX;
            CENTER_Y = size / 2 + panOffsetY;
            SCALE = (size / 2) / 1200 * 0.84 * zoomLevel; // Scale to fit 1200 units at edge with some padding
            
            drawCanvas();
            updateHeroDots();
        }
        
        // Update zoom level display
        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }
        
        // Range constants - edit these values to change ranges and labels
        const DANGER_ZONE_RANGE = 1020;
        const DANGER_ZONE_LABEL = 'Earshot / Danger Zone';
        const IN_THE_AREA_RANGE = 322;
        const IN_THE_AREA_LABEL = 'In the area';
        const NEARBY_RANGE = 252;
        const NEARBY_LABEL = 'Nearby';
        const ADJACENT_RANGE = 166;
        const ADJACENT_RANGE_LABEL = 'Adjacent';

        let heroes = [];
        let draggingHero = null;
        let showAdjacentRange = false;
        let showNearbyRange = false;
        let showInTheAreaRange = false;
        let highlightIntersections = false;
        let selectedHeroes = [];
        let dragStartPos = null;
        let isShiftDragging = false;
        let isCtrlDragging = false;
        let hotkeyOffset = 0;
        
        // History management
        let history = [];
        let currentHistoryIndex = -1;
        const MAX_HISTORY = 20;
        let historyCounter = 0;
        
        // Formations management
        let savedFormations = [];
        let savedFormationCounter = 0;
        
        // Pre-bundled formations
        const preBundledFormations = [
            {
                name: "Narrow 0-5-2 Formation",
                code: `[hotkey-000:FlagHero]
degree = 270.000000
distance = 253.000000
hero = 1

[hotkey-001:FlagHero]
degree = 223.860000
distance = 227.550000
hero = 2

[hotkey-002:FlagHero]
degree = 180.000000
distance = 219.100000
hero = 3

[hotkey-003:FlagHero]
degree = 136.140000
distance = 227.550000
hero = 4

[hotkey-004:FlagHero]
degree = 90.000000
distance = 253.000000
hero = 5

[hotkey-005:FlagHero]
degree = 200.690000
distance = 445.830000
hero = 6

[hotkey-006:FlagHero]
degree = 159.310000
distance = 445.830000
hero = 7`
            },
            {
                name: "Wide 0-5-2 Formation",
                code: `[hotkey-000:FlagHero]
degree = 270.000000
distance = 472.100000
hero = 1

[hotkey-001:FlagHero]
degree = 243.430000
distance = 282.860000
hero = 2

[hotkey-002:FlagHero]
degree = 180.000000
distance = 126.500000
hero = 3

[hotkey-003:FlagHero]
degree = 116.570000
distance = 282.860000
hero = 4

[hotkey-004:FlagHero]
degree = 90.000000
distance = 472.100000
hero = 5

[hotkey-005:FlagHero]
degree = 200.100000
distance = 368.030000
hero = 6

[hotkey-006:FlagHero]
degree = 159.900000
distance = 368.030000
hero = 7`
            }
        ];

        // Parse configuration from code
        function parseConfig(code) {
            const heroes = [];
            const sections = code.split(/\[hotkey-\d+:FlagHero\]/g).filter(s => s.trim());
            
            sections.forEach(section => {
                const degreeMatch = section.match(/degree\s*=\s*([\d.]+)/);
                const distanceMatch = section.match(/distance\s*=\s*([\d.]+)/);
                const heroMatch = section.match(/hero\s*=\s*(\d+)/);

                if (degreeMatch && distanceMatch && heroMatch) {
                    heroes.push({
                        degree: parseFloat(degreeMatch[1]),
                        distance: parseFloat(distanceMatch[1]),
                        hero: parseInt(heroMatch[1])
                    });
                }
            });

            return heroes;
        }

        // Generate configuration code
        function generateConfig(heroes) {
            return heroes.map((hero, index) => {
                const hotkeyNumber = index + hotkeyOffset;
                return `[hotkey-${String(hotkeyNumber).padStart(3, '0')}:FlagHero]
degree = ${hero.degree.toFixed(6)}
distance = ${hero.distance.toFixed(6)}
hero = ${hero.hero}`;
            }).join('\n\n');
        }

        // Convert polar to cartesian coordinates
        function polarToCartesian(degree, distance) {
            // Convert degree to radians, adjust for 0¬∞ being at top
            const radians = (degree - 90) * Math.PI / 180;
            const x = CENTER_X + Math.cos(radians) * distance * SCALE;
            const y = CENTER_Y + Math.sin(radians) * distance * SCALE;
            return { x, y };
        }

        // Convert cartesian to polar coordinates
        function cartesianToPolar(x, y) {
            const dx = x - CENTER_X;
            const dy = y - CENTER_Y;
            const distance = Math.sqrt(dx * dx + dy * dy) / SCALE;
            let degree = Math.atan2(dy, dx) * 180 / Math.PI + 90;
            if (degree < 0) degree += 360;
            return { degree, distance };
        }
        
        // Check if a point is within a circle's range
        function isPointInRange(pointX, pointY, centerX, centerY, range) {
            const dx = pointX - centerX;
            const dy = pointY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= range * SCALE;
        }
        
        // Check if a range circle intersects any hero centers (excluding its own center)
        function checkIntersections(centerX, centerY, range) {
            const tolerance = 1; // Small tolerance for floating point comparison
            
            // Check player center (if not the circle's own center)
            const distToPlayer = Math.sqrt((CENTER_X - centerX) ** 2 + (CENTER_Y - centerY) ** 2);
            if (distToPlayer > tolerance && isPointInRange(CENTER_X, CENTER_Y, centerX, centerY, range)) {
                return true;
            }
            
            // Check all hero centers (excluding the circle's own center)
            for (const hero of heroes) {
                const pos = polarToCartesian(hero.degree, hero.distance);
                const distToHero = Math.sqrt((pos.x - centerX) ** 2 + (pos.y - centerY) ** 2);
                if (distToHero > tolerance && isPointInRange(pos.x, pos.y, centerX, centerY, range)) {
                    return true;
                }
            }
            
            return false;
        }

        // Draw the canvas
        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid (100 game units per square)
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            const gridSpacing = 100 * SCALE; // 100 game units
            
            // Calculate grid range based on visible area
            const maxDistance = Math.max(canvasSize / SCALE, 2400); // At least cover danger zone
            const gridStart = -Math.ceil(maxDistance / 100) * 100;
            const gridEnd = Math.ceil(maxDistance / 100) * 100;
            
            // Draw vertical lines
            for (let x = gridStart; x <= gridEnd; x += 100) {
                const screenX = CENTER_X + x * SCALE;
                if (screenX >= 0 && screenX <= canvasSize) {
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvasSize);
                    ctx.stroke();
                }
            }
            
            // Draw horizontal lines
            for (let y = gridStart; y <= gridEnd; y += 100) {
                const screenY = CENTER_Y + y * SCALE;
                if (screenY >= 0 && screenY <= canvasSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvasSize, screenY);
                    ctx.stroke();
                }
            }

            // Draw center crosshair
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(CENTER_X - 20, CENTER_Y);
            ctx.lineTo(CENTER_X + 20, CENTER_Y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(CENTER_X, CENTER_Y - 20);
            ctx.lineTo(CENTER_X, CENTER_Y + 20);
            ctx.stroke();

            // Draw direction indicator (0¬∞ = front)
            ctx.strokeStyle = '#4a9eff';
            ctx.fillStyle = '#4a9eff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(CENTER_X, CENTER_Y - 30);
            ctx.lineTo(CENTER_X, CENTER_Y - 60);
            ctx.stroke();
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(CENTER_X, CENTER_Y - 60);
            ctx.lineTo(CENTER_X - 5, CENTER_Y - 50);
            ctx.lineTo(CENTER_X + 5, CENTER_Y - 50);
            ctx.closePath();
            ctx.fill();

            // Draw earshot / danger zone circle
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, DANGER_ZONE_RANGE * SCALE, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Label the circle
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(`${DANGER_ZONE_LABEL} (${DANGER_ZONE_RANGE})`, CENTER_X, CENTER_Y - DANGER_ZONE_RANGE * SCALE - 8);

            // Draw In the area range circles if enabled
            if (showInTheAreaRange) {
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                
                // Player In the area circle
                const playerIntersects = highlightIntersections && checkIntersections(CENTER_X, CENTER_Y, IN_THE_AREA_RANGE);
                ctx.strokeStyle = playerIntersects ? '#ff000088' : '#00ffff88';
                ctx.beginPath();
                ctx.arc(CENTER_X, CENTER_Y, IN_THE_AREA_RANGE * SCALE, 0, Math.PI * 2);
                ctx.stroke();
                
                // Hero In the area circles
                heroes.forEach(hero => {
                    const pos = polarToCartesian(hero.degree, hero.distance);
                    const heroIntersects = highlightIntersections && checkIntersections(pos.x, pos.y, IN_THE_AREA_RANGE);
                    ctx.strokeStyle = heroIntersects ? '#ff000088' : '#00ffff88';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, IN_THE_AREA_RANGE * SCALE, 0, Math.PI * 2);
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);
            }

            // Draw Nearby range circles if enabled
            if (showNearbyRange) {
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                
                // Player Nearby circle
                const playerNearbyIntersects = highlightIntersections && checkIntersections(CENTER_X, CENTER_Y, NEARBY_RANGE);
                ctx.strokeStyle = playerNearbyIntersects ? '#ff000088' : '#00ff8888';
                ctx.beginPath();
                ctx.arc(CENTER_X, CENTER_Y, NEARBY_RANGE * SCALE, 0, Math.PI * 2);
                ctx.stroke();
                
                // Hero Nearby circles
                heroes.forEach(hero => {
                    const pos = polarToCartesian(hero.degree, hero.distance);
                    const heroNearbyIntersects = highlightIntersections && checkIntersections(pos.x, pos.y, NEARBY_RANGE);
                    ctx.strokeStyle = heroNearbyIntersects ? '#ff000088' : '#00ff8888';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, NEARBY_RANGE * SCALE, 0, Math.PI * 2);
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);
            }

            // Draw Adjacent range circles if enabled
            if (showAdjacentRange) {
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                
                // Player Adjacent circle
                const playerAdjacentIntersects = highlightIntersections && checkIntersections(CENTER_X, CENTER_Y, ADJACENT_RANGE);
                ctx.strokeStyle = playerAdjacentIntersects ? '#ff000088' : '#ffff0088';
                ctx.beginPath();
                ctx.arc(CENTER_X, CENTER_Y, ADJACENT_RANGE * SCALE, 0, Math.PI * 2);
                ctx.stroke();
                
                // Hero Adjacent circles
                heroes.forEach(hero => {
                    const pos = polarToCartesian(hero.degree, hero.distance);
                    const heroAdjacentIntersects = highlightIntersections && checkIntersections(pos.x, pos.y, ADJACENT_RANGE);
                    ctx.strokeStyle = heroAdjacentIntersects ? '#ff000088' : '#ffff0088';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, ADJACENT_RANGE * SCALE, 0, Math.PI * 2);
                    ctx.stroke();
                });
                
                ctx.setLineDash([]);
            }

            // Draw lines from player to heroes
            heroes.forEach(hero => {
                const pos = polarToCartesian(hero.degree, hero.distance);
                ctx.strokeStyle = '#ff6b6b44';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(CENTER_X, CENTER_Y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            });
            
            // Draw grid legend
            ctx.fillStyle = '#888';
            ctx.font = '11px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Grid: 100 units/square', 10, 20);
        }

        // Update hero dots
        function updateHeroDots() {
            heroContainer.innerHTML = '';

            // Player dot
            const playerDot = document.createElement('div');
            playerDot.className = 'hero-dot player';
            playerDot.textContent = 'P';
            playerDot.style.left = CENTER_X + 'px';
            playerDot.style.top = CENTER_Y + 'px';
            heroContainer.appendChild(playerDot);

            // Hero dots
            heroes.forEach((hero, index) => {
                const pos = polarToCartesian(hero.degree, hero.distance);
                const dot = document.createElement('div');
                dot.className = `hero-dot member member-${hero.hero}`;
                dot.textContent = hero.hero;
                dot.style.left = pos.x + 'px';
                dot.style.top = pos.y + 'px';
                dot.dataset.index = index;

                // Drag and selection functionality
                dot.addEventListener('mousedown', (e) => {
                    // Store the starting position for constraint calculations
                    const pos = polarToCartesian(hero.degree, hero.distance);
                    dragStartPos = { x: pos.x, y: pos.y };
                    
                    if (e.shiftKey && !e.ctrlKey && !e.altKey) {
                        // Toggle selection with shift-click
                        const selectedIndex = selectedHeroes.indexOf(index);
                        if (selectedIndex === -1) {
                            selectedHeroes.push(index);
                            dot.classList.add('selected');
                        } else {
                            selectedHeroes.splice(selectedIndex, 1);
                            dot.classList.remove('selected');
                        }
                    } else {
                        // If not shift-clicking, clear selection and start dragging
                        if (!selectedHeroes.includes(index)) {
                            // Clear previous selection if this hero isn't already selected
                            document.querySelectorAll('.hero-dot.selected').forEach(el => {
                                el.classList.remove('selected');
                            });
                            selectedHeroes = [];
                        }
                        
                        // Start dragging this hero and all selected heroes
                        draggingHero = index;
                        if (!selectedHeroes.includes(index)) {
                            selectedHeroes = [index];
                            dot.classList.add('selected');
                        }
                    }
                    e.preventDefault();
                });

                heroContainer.appendChild(dot);
            });
        }

        // Update from code
        function updateFromCode(addToHistory = false) {
            heroes = parseConfig(codeEditor.value);
            drawCanvas();
            updateHeroDots();
            
            if (addToHistory) {
                addHistoryEntry(codeEditor.value);
            }
        }
        
        // Add entry to history
        function addHistoryEntry(codeState) {
            // Don't add if identical to current state
            if (history.length > 0 && history[currentHistoryIndex].code === codeState) {
                return;
            }
            
            // Always append to history, never truncate
            // Increment counter and add new state with metadata
            historyCounter++;
            history.push({
                code: codeState,
                timestamp: new Date(),
                stateNumber: historyCounter
            });
            
            // Limit history size (remove oldest)
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
            
            // Always point to the latest entry
            currentHistoryIndex = history.length - 1;
            updateHistoryUI();
        }
        
        // Go to specific history state
        function goToHistoryState(index) {
            if (index >= 0 && index < history.length) {
                currentHistoryIndex = index;
                codeEditor.value = history[index].code;
                updateFromCode(false);
                updateHistoryUI();
            }
        }
        
        // Update history UI
        function updateHistoryUI() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            
            history.forEach((state, index) => {
                const item = document.createElement('div');
                item.className = 'history-item' + (index === currentHistoryIndex ? ' active' : '');
                
                const timestamp = document.createElement('div');
                timestamp.className = 'history-timestamp';
                timestamp.textContent = state.timestamp.toLocaleTimeString();
                
                const preview = document.createElement('div');
                preview.className = 'history-preview';
                preview.textContent = `State ${state.stateNumber}`;
                
                item.appendChild(timestamp);
                item.appendChild(preview);
                
                item.addEventListener('click', () => goToHistoryState(index));
                
                historyList.appendChild(item);
            });
            
            // Scroll to bottom - use setTimeout to ensure DOM has updated
            setTimeout(() => {
                historyList.scrollTop = historyList.scrollHeight;
            }, 0);
        }

        // Update code from heroes
        function updateCode() {
            const cursorPos = codeEditor.selectionStart;
            codeEditor.value = generateConfig(heroes);
            codeEditor.setSelectionRange(cursorPos, cursorPos);
        }

        // Event listeners
        let codeChangeTimeout;
        codeEditor.addEventListener('input', () => {
            updateFromCode(false);
            
            // Add to history after a delay to avoid adding every keystroke
            clearTimeout(codeChangeTimeout);
            codeChangeTimeout = setTimeout(() => {
                addHistoryEntry(codeEditor.value);
            }, 1000);
        });

        // AoE range checkbox is now handled in the controls state section

        // Clear selection when clicking on the canvas background
        canvas.addEventListener('mousedown', (e) => {
            // Middle mouse button for panning
            if (e.button === 1) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                document.querySelector('.canvas-container').classList.add('panning');
                return;
            }
            
            // Only clear if we're clicking on the background (not on a hero dot)
            // We can determine this by checking if the click event target is the canvas itself
            if (e.target === canvas) {
                selectedHeroes = [];
                document.querySelectorAll('.hero-dot.selected').forEach(dot => {
                    dot.classList.remove('selected');
                });
            }
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
            zoomLevel = Math.max(0.5, Math.min(3, zoomLevel + delta));
            
            updateCanvasDimensions();
            updateZoomDisplay();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const deltaX = e.clientX - panStartX;
                const deltaY = e.clientY - panStartY;
                
                panOffsetX += deltaX;
                panOffsetY += deltaY;
                
                panStartX = e.clientX;
                panStartY = e.clientY;
                
                updateCanvasDimensions();
                return;
            }
            
            if (draggingHero !== null) {
                const rect = canvas.getBoundingClientRect();
                let x = e.clientX - rect.left;
                let y = e.clientY - rect.top;
                
                // Check for modifier keys
                isShiftDragging = e.shiftKey;
                isCtrlDragging = e.ctrlKey;
                if (isShiftDragging && dragStartPos) {
                    // Calculate which direction has the larger movement
                    const deltaX = Math.abs(x - dragStartPos.x);
                    const deltaY = Math.abs(y - dragStartPos.y);
                    
                    // Constrain to horizontal or vertical based on larger movement
                    if (deltaX > deltaY) {
                        // Horizontal constraint
                        y = dragStartPos.y;
                    } else {
                        // Vertical constraint
                        x = dragStartPos.x;
                    }
                }

                // Get cartesian coordinates for current position
                const polar = cartesianToPolar(x, y);
                
                // For group movement, we need to work in cartesian coordinates
                const origHero = heroes[draggingHero];
                const origPos = polarToCartesian(origHero.degree, origHero.distance);
                
                // Calculate the delta in cartesian space
                const deltaX = x - origPos.x;
                const deltaY = y - origPos.y;
                
                // Apply to all selected heroes or just the dragged one
                if (selectedHeroes.length > 0) {
                    if (isCtrlDragging) {
                        // Ctrl is held - rotate around player (original behavior)
                        const deltaAngle = polar.degree - origHero.degree;
                        const deltaDistance = polar.distance - origHero.distance;
                        
                        selectedHeroes.forEach(idx => {
                            heroes[idx].degree = (heroes[idx].degree + deltaAngle) % 360;
                            heroes[idx].distance = Math.max(10, heroes[idx].distance + deltaDistance);
                        });
                    } else {
                        // Normal mode - maintain formation (cartesian movement)
                        selectedHeroes.forEach(idx => {
                            // Convert each hero to cartesian, move, then back to polar
                            const heroPos = polarToCartesian(heroes[idx].degree, heroes[idx].distance);
                            const newX = heroPos.x + deltaX;
                            const newY = heroPos.y + deltaY;
                            
                            // Convert back to polar coordinates
                            const newPolar = cartesianToPolar(newX, newY);
                            heroes[idx].degree = newPolar.degree;
                            heroes[idx].distance = Math.max(10, newPolar.distance);
                        });
                    }
                } else {
                    // If no selection, just move the dragged hero
                    heroes[draggingHero].degree = polar.degree;
                    heroes[draggingHero].distance = Math.max(10, polar.distance);
                }
                
                updateCode();
                drawCanvas();
                updateHeroDots();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                document.querySelector('.canvas-container').classList.remove('panning');
            }
            
            if (draggingHero !== null) {
                // Add to history when drag ends
                addHistoryEntry(codeEditor.value);
            }
            
            draggingHero = null;
            dragStartPos = null;
            isShiftDragging = false;
            isCtrlDragging = false;
            
            // Keep selection active after drag
            updateHeroDots();
            selectedHeroes.forEach(index => {
                const dot = document.querySelector(`.hero-dot[data-index="${index}"]`);
                if (dot) dot.classList.add('selected');
            });
        });
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z for undo
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                if (currentHistoryIndex > 0) {
                    goToHistoryState(currentHistoryIndex - 1);
                }
                return;
            }
            
            // Arrow keys to nudge selected heroes by 1 unit
            if (selectedHeroes.length > 0 && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                
                // Determine movement direction in cartesian space (1 unit = 1 game unit)
                let deltaX = 0;
                let deltaY = 0;
                
                switch(e.key) {
                    case 'ArrowUp':
                        deltaY = -1;
                        break;
                    case 'ArrowDown':
                        deltaY = 1;
                        break;
                    case 'ArrowLeft':
                        deltaX = -1;
                        break;
                    case 'ArrowRight':
                        deltaX = 1;
                        break;
                }
                
                // Move all selected heroes
                selectedHeroes.forEach(idx => {
                    // Convert current position to cartesian
                    const heroPos = polarToCartesian(heroes[idx].degree, heroes[idx].distance);
                    
                    // Apply movement in cartesian space
                    const newX = heroPos.x + deltaX * SCALE;
                    const newY = heroPos.y + deltaY * SCALE;
                    
                    // Convert back to polar coordinates
                    const newPolar = cartesianToPolar(newX, newY);
                    heroes[idx].degree = newPolar.degree;
                    heroes[idx].distance = Math.max(10, newPolar.distance);
                });
                
                updateCode();
                drawCanvas();
                updateHeroDots();
                
                // Restore selection
                selectedHeroes.forEach(index => {
                    const dot = document.querySelector(`.hero-dot[data-index="${index}"]`);
                    if (dot) dot.classList.add('selected');
                });
                
                // Add to history after a short delay to avoid spamming history
                clearTimeout(window.arrowKeyHistoryTimeout);
                window.arrowKeyHistoryTimeout = setTimeout(() => {
                    addHistoryEntry(codeEditor.value);
                }, 500);
            }
        });

        // Load saved formations from localStorage
        function loadSavedFormations() {
            const savedFormationsStr = localStorage.getItem('heroPositionSavedFormations');
            if (savedFormationsStr) {
                try {
                    savedFormations = JSON.parse(savedFormationsStr);
                    // Find the highest counter value
                    savedFormations.forEach(formation => {
                        const match = formation.name.match(/Formation (\d+)$/);
                        if (match && parseInt(match[1]) >= savedFormationCounter) {
                            savedFormationCounter = parseInt(match[1]) + 1;
                        }
                    });
                } catch (e) {
                    console.error('Error parsing saved formations:', e);
                    savedFormations = [];
                }
            }
        }
        
        // Save formations to localStorage
        function saveFormations() {
            try {
                localStorage.setItem('heroPositionSavedFormations', JSON.stringify(savedFormations));
            } catch (e) {
                console.error('Error saving formations to localStorage:', e);
                // Show a temporary notification
                alert('Failed to save formations. Your browser may have localStorage disabled or full.');
            }
        }
        
        // Render formations
        function renderFormations() {
            // Render pre-bundled formations
            const prebundledContainer = document.getElementById('prebundledFormations');
            prebundledContainer.innerHTML = '';
            
            preBundledFormations.forEach((formation, index) => {
                const item = document.createElement('div');
                item.className = 'formation-item';
                item.textContent = formation.name;
                item.addEventListener('click', () => loadFormation(formation.code));
                prebundledContainer.appendChild(item);
            });
            
            // Render saved formations
            const savedContainer = document.getElementById('savedFormations');
            savedContainer.innerHTML = '';
            
            if (savedFormations.length === 0) {
                const placeholder = document.createElement('div');
                placeholder.className = 'formation-item';
                placeholder.textContent = 'No saved formations';
                placeholder.style.fontStyle = 'italic';
                placeholder.style.color = '#777';
                savedContainer.appendChild(placeholder);
            } else {
                savedFormations.forEach((formation, index) => {
                    const item = document.createElement('div');
                    item.className = 'formation-item user-saved';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'formation-name';
                    nameSpan.textContent = formation.name;
                    nameSpan.addEventListener('dblclick', (e) => {
                        nameSpan.contentEditable = true;
                        nameSpan.focus();
                        document.execCommand('selectAll', false, null);
                    });
                    
                    nameSpan.addEventListener('blur', () => {
                        nameSpan.contentEditable = false;
                        formation.name = nameSpan.textContent;
                        saveFormations();
                    });
                    
                    nameSpan.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            nameSpan.blur();
                        }
                    });
                    
                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-formation';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = 'Delete formation';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        savedFormations.splice(index, 1);
                        saveFormations();
                        renderFormations();
                    });
                    
                    item.appendChild(nameSpan);
                    item.appendChild(deleteBtn);
                    
                    item.addEventListener('click', (e) => {
                        if (e.target !== deleteBtn && nameSpan.contentEditable !== 'true') {
                            loadFormation(formation.code);
                        }
                    });
                    
                    savedContainer.appendChild(item);
                });
            }
        }
        
        // Load a formation
        function loadFormation(code) {
            codeEditor.value = code;
            updateFromCode(true);
        }
        
        // Save current formation
        document.getElementById('saveFormationBtn').addEventListener('click', () => {
            const formationName = `Formation ${savedFormationCounter++}`;
            savedFormations.push({
                name: formationName,
                code: codeEditor.value
            });
            saveFormations();
            renderFormations();
        });
        
        // Initialize formations
        loadSavedFormations();
        renderFormations();
        
        // Set initial formation from first pre-bundled formation
        codeEditor.value = preBundledFormations[0].code;
        
        // Help modal functionality
        const helpButton = document.getElementById('helpButton');
        const helpModal = document.getElementById('helpModal');
        const closeModal = document.getElementById('closeModal');
        
        // Controls panel toggle functionality
        const settingsButton = document.getElementById('settingsButton');
        const controlsPanel = document.getElementById('controlsPanel');
        const showAdjacentRangeCheckbox = document.getElementById('showAdjacentRange');
        const showNearbyRangeCheckbox = document.getElementById('showNearbyRange');
        const showInTheAreaRangeCheckbox = document.getElementById('showInTheAreaRange');
        const highlightIntersectionsCheckbox = document.getElementById('highlightIntersections');
        
        // Load controls state from localStorage
        function loadControlsState() {
            // Load panel visibility
            const panelVisible = localStorage.getItem('heroPositionControlsVisible');
            let controlsPanelVisible = panelVisible === null ? true : panelVisible === 'true';
            
            if (!controlsPanelVisible) {
                controlsPanel.classList.add('hidden');
            }
            
            // Load Adjacent range checkbox state
            const adjacentRangeVisible = localStorage.getItem('heroPositionAdjacentRangeVisible');
            showAdjacentRange = adjacentRangeVisible === 'true';
            showAdjacentRangeCheckbox.checked = showAdjacentRange;
            
            // Load Nearby range checkbox state
            const nearbyRangeVisible = localStorage.getItem('heroPositionNearbyRangeVisible');
            showNearbyRange = nearbyRangeVisible === 'true';
            showNearbyRangeCheckbox.checked = showNearbyRange;
            
            // Load In the area range checkbox state
            const inTheAreaRangeVisible = localStorage.getItem('heroPositionInTheAreaRangeVisible');
            showInTheAreaRange = inTheAreaRangeVisible === 'true';
            showInTheAreaRangeCheckbox.checked = showInTheAreaRange;
            
            // Load highlight intersections checkbox state
            const highlightIntersectionsVisible = localStorage.getItem('heroPositionHighlightIntersections');
            highlightIntersections = highlightIntersectionsVisible === 'true';
            highlightIntersectionsCheckbox.checked = highlightIntersections;
        }
        
        // Save controls state to localStorage
        function saveControlsState() {
            localStorage.setItem('heroPositionControlsVisible', controlsPanel.classList.contains('hidden') ? 'false' : 'true');
            localStorage.setItem('heroPositionAdjacentRangeVisible', showAdjacentRange.toString());
            localStorage.setItem('heroPositionNearbyRangeVisible', showNearbyRange.toString());
            localStorage.setItem('heroPositionInTheAreaRangeVisible', showInTheAreaRange.toString());
            localStorage.setItem('heroPositionHighlightIntersections', highlightIntersections.toString());
        }
        
        // Toggle controls panel visibility
        settingsButton.addEventListener('click', () => {
            controlsPanel.classList.toggle('hidden');
            saveControlsState();
        });
        
        // Update Adjacent range visibility and save state
        showAdjacentRangeCheckbox.addEventListener('change', (e) => {
            showAdjacentRange = e.target.checked;
            drawCanvas();
            saveControlsState();
        });
        
        // Update Nearby range visibility and save state
        showNearbyRangeCheckbox.addEventListener('change', (e) => {
            showNearbyRange = e.target.checked;
            drawCanvas();
            saveControlsState();
        });
        
        // Update In the area range visibility and save state
        showInTheAreaRangeCheckbox.addEventListener('change', (e) => {
            showInTheAreaRange = e.target.checked;
            drawCanvas();
            saveControlsState();
        });
        
        // Update highlight intersections and save state
        highlightIntersectionsCheckbox.addEventListener('change', (e) => {
            highlightIntersections = e.target.checked;
            drawCanvas();
            saveControlsState();
        });
        
        helpButton.addEventListener('click', () => {
            helpModal.classList.add('active');
        });
        
        closeModal.addEventListener('click', () => {
            helpModal.classList.remove('active');
        });
        
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.remove('active');
            }
        });
        
        // Update dynamic labels
        document.getElementById('inTheAreaRangeLabel').textContent = `${IN_THE_AREA_LABEL} (${IN_THE_AREA_RANGE})`;
        document.getElementById('nearbyRangeLabel').textContent = `${NEARBY_LABEL} (${NEARBY_RANGE})`;
        document.getElementById('adjacentRangeLabel').textContent = `${ADJACENT_RANGE_LABEL} (${ADJACENT_RANGE})`;
        
        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', () => {
            zoomLevel = Math.min(3, zoomLevel + 0.2);
            updateCanvasDimensions();
            updateZoomDisplay();
        });
        
        document.getElementById('zoomOut').addEventListener('click', () => {
            zoomLevel = Math.max(0.5, zoomLevel - 0.2);
            updateCanvasDimensions();
            updateZoomDisplay();
        });
        
        document.getElementById('zoomReset').addEventListener('click', () => {
            zoomLevel = 1.0;
            panOffsetX = 0;
            panOffsetY = 0;
            updateCanvasDimensions();
            updateZoomDisplay();
        });
        
        // Hotkey offset control
        const hotkeyOffsetInput = document.getElementById('hotkeyOffset');
        
        // Load hotkey offset from localStorage
        const savedOffset = localStorage.getItem('heroPositionHotkeyOffset');
        if (savedOffset !== null) {
            hotkeyOffset = parseInt(savedOffset);
            hotkeyOffsetInput.value = hotkeyOffset;
        }
        
        // Update hotkey offset when changed
        hotkeyOffsetInput.addEventListener('input', (e) => {
            const value = parseInt(e.target.value) || 0;
            hotkeyOffset = Math.max(0, Math.min(999, value));
            hotkeyOffsetInput.value = hotkeyOffset;
            localStorage.setItem('heroPositionHotkeyOffset', hotkeyOffset.toString());
            updateCode();
        });
        
        // Load controls state
        loadControlsState();
        
        // Set up resize observer to handle window resizing
        const resizeObserver = new ResizeObserver(() => {
            updateCanvasDimensions();
        });
        resizeObserver.observe(document.querySelector('.canvas-container'));
        
        // Initial setup
        updateCanvasDimensions();
        updateFromCode(true);
    </script>
</body>
</html>
